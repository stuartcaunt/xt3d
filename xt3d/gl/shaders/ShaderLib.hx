package xt3d.gl.shaders;

import xt3d.utils.XT;
import xt3d.gl.shaders.ShaderTypedefs;
import xt3d.gl.shaders.ShaderUtils;

class ShaderLib  {

	public static var EXTENSION_SEPARATOR:String = "+";

	// Properties

	// Members
	private static var _instance:ShaderLib = null;
	private var _shaderConfigs:Map<String, ShaderInfo> = new Map<String, ShaderInfo>();
	private var _baseShaderConfigs:Map<String, ShaderInfo>;
	private var _shaderExtensions:Map<String, ShaderExtensionInfo>;


	private function new() {
	}


	/* ----------- Properties ----------- */


	public inline function get_shaderConfigs():Map<String, ShaderInfo> {
		return _shaderConfigs;
	}


	/* --------- Implementation --------- */


	public static function instance():ShaderLib {
		if (_instance == null) {
			_instance = new ShaderLib();
			_instance.init();
		}

		return _instance;
	}

	public function init():Void {
		this._baseShaderConfigs = [
			"generic" => {
				vertexProgram: "generic_vertex",
				fragmentProgram: "generic_fragment",
				commonUniformGroups: ["matrixCommon", "time", "opacity"],
				uniforms: [
					"color" => { name: "u_color", type: "vec4", shader: "vf", defaultValue: "[1, 1, 1, 1]" }
				]
			},
			"picking" => {
				vertexProgram: "picking_vertex",
				fragmentProgram: "picking_fragment",
				commonUniformGroups: ["matrixCommon"],
				uniforms: [
					"objectId" => { name: "u_objectId", type: "vec2", shader: "f", defaultValue: "[0.0, 0.0]" }
				]
			},
			"depth" => {
				vertexProgram: "depth_vertex",
				fragmentProgram: "depth_fragment",
				commonUniformGroups: ["matrixCommon", "depth"]
			},
			"logDepth" => {
				vertexProgram: "logDepth_vertex",
				fragmentProgram: "logDepth_fragment",
				commonUniformGroups: ["matrixCommon", "depth"]
			},
			"depthDebug" => {
				vertexProgram: "depth_debug_vertex",
				fragmentProgram: "depth_debug_fragment",
				commonUniformGroups: ["matrixCommon", "texture"]
			},
			"blurX9" => {
				vertexProgram: "blur9_vertex",
				fragmentProgram: "blur9_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				vertexDefines: ["#define BLUR_X"],
				uniforms: [
					"spread" => { name: "u_spread", type: "float", shader: "v", defaultValue: "1.0" },
					"textureWidth" => { name: "u_textureWidth", type: "float", shader: "v", defaultValue: "1" }
				]
			},
			"blurY9" => {
				vertexProgram: "blur9_vertex",
				fragmentProgram: "blur9_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				vertexDefines: ["#define BLUR_Y"],
				uniforms: [
					"spread" => { name: "u_spread", type: "float", shader: "v", defaultValue: "1.0" },
					"textureHeight" => { name: "u_textureHeight", type: "float", shader: "v", defaultValue: "1" }
				]
			},
			"blurX15" => {
				vertexProgram: "blur15_vertex",
				fragmentProgram: "blur15_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				vertexDefines: ["#define BLUR_X"],
				uniforms: [
					"spread" => { name: "u_spread", type: "float", shader: "v", defaultValue: "1.0" },
					"textureWidth" => { name: "u_textureWidth", type: "float", shader: "v", defaultValue: "1" }
				]
			},
			"blurY15" => {
				vertexProgram: "blur15_vertex",
				fragmentProgram: "blur15_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				vertexDefines: ["#define BLUR_Y"],
				uniforms: [
					"spread" => { name: "u_spread", type: "float", shader: "v", defaultValue: "1.0" },
					"textureHeight" => { name: "u_textureHeight", type: "float", shader: "v", defaultValue: "1" }
				]
			},
			"depthOfFieldX" => {
				vertexProgram: "depthOfField_vertex",
				fragmentProgram: "depthOfField_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				vertexDefines: ["#define DoF_X"],
				fragmentIncludes: ["getDepth_fragment_part"],
				uniforms: [
					"depthTexture" => { name: "u_depthTexture", type: "texture", shader: "f" },
					"depthNear" => { name: "u_depthNear", type: "float", shader: "f", defaultValue: "1.0" },
					"depthFar" => { name: "u_depthFar", type: "float", shader: "f", defaultValue: "1000.0" },
					"focalDepth" => { name: "u_focalDepth", type: "float", shader: "f", defaultValue: "0.5" },
					"focalRange" => { name: "u_focalRange", type: "float", shader: "f", defaultValue: "0.2" },
					"textureWidth" => { name: "u_textureWidth", type: "float", shader: "v", defaultValue: "1" }
				]
			},
			"depthOfFieldY" => {
				vertexProgram: "depthOfField_vertex",
				fragmentProgram: "depthOfField_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				vertexDefines: ["#define DoF_Y"],
				fragmentIncludes: ["getDepth_fragment_part"],
				uniforms: [
					"depthTexture" => { name: "u_depthTexture", type: "texture", shader: "f" },
					"depthNear" => { name: "u_depthNear", type: "float", shader: "f", defaultValue: "1.0" },
					"depthFar" => { name: "u_depthFar", type: "float", shader: "f", defaultValue: "1000.0" },
					"focalDepth" => { name: "u_focalDepth", type: "float", shader: "f", defaultValue: "0.5" },
					"focalRange" => { name: "u_focalRange", type: "float", shader: "f", defaultValue: "0.2" },
					"textureHeight" => { name: "u_textureHeight", type: "float", shader: "v", defaultValue: "1" }
				]
			},
			"depthOfFieldBokeh" => {
				vertexProgram: "depthOfFieldBokeh_vertex",
				fragmentProgram: "depthOfFieldBokeh_fragment",
				commonUniformGroups: ["matrixCommon", "texture"],
				fragmentIncludes: ["getDepth_fragment_part"],
				uniforms: [
					"depthTexture" => { name: "u_depthTexture", type: "texture", shader: "f" },
					"depthNear" => { name: "u_depthNear", type: "float", shader: "f", defaultValue: "1.0" },
					"depthFar" => { name: "u_depthFar", type: "float", shader: "f", defaultValue: "1000.0" },
					"focalDepth" => { name: "u_focalDepth", type: "float", shader: "f", defaultValue: "15.0" },
					"focalRange" => { name: "u_focalRange", type: "float", shader: "f", defaultValue: "4.0" },
					"highlightThreshold" => { name: "u_highlightThreshold", type: "float", shader: "f", defaultValue: "0.5" },
					"highlightGain" => { name: "u_highlightGain", type: "float", shader: "f", defaultValue: "5.0" },
					"chromaticFringe" => { name: "u_chromaticFringe", type: "float", shader: "f", defaultValue: "0.5" },
					"edgeBias" => { name: "u_edgeBias", type: "float", shader: "f", defaultValue: "0.4" },
					"dither" => { name: "u_dither", type: "float", shader: "f", defaultValue: "0.0001" },
					"textureWidth" => { name: "u_textureWidth", type: "float", shader: "f", defaultValue: "1" },
					"textureHeight" => { name: "u_textureHeight", type: "float", shader: "f", defaultValue: "1" }
				]
			}
		];

		this._shaderExtensions = [
			"vertexColors" => {
				vertexDefines: ["#define USE_VERTEX_COLOR"]
			},

			"texture" => {
				vertexDefines: ["#define USE_TEXTURE"],
				fragmentDefines: ["#define USE_TEXTURE"],
				commonUniformGroups: ["texture"]
			},

			"gouraud" => {
				vertexDefines: ["#define GOURAUD_LIGHTING"],
				fragmentDefines: ["#define GOURAUD_LIGHTING"],
				vertexIncludes: ["gouraud_vertex_part"],
				commonUniformGroups: ["lighting"]
			},

			"phong" => {
				vertexDefines: ["#define PHONG_LIGHTING"],
				fragmentDefines: ["#define PHONG_LIGHTING"],
				fragmentIncludes: ["phong_fragment_part"],
				commonUniformGroups: ["lighting"]
			},

			"material" => {
				vertexDefines: ["#define USE_MATERIAL_COLOR"],
				fragmentDefines: ["#define USE_MATERIAL_COLOR"],
				commonUniformGroups: ["material"]
			},

			"facePicking" => {
				vertexDefines: ["#define FACE_PICKING"],
				fragmentDefines: ["#define FACE_PICKING"],
				attributes: [
					"faceId" => { name: "a_faceId", type: "vec2" }
				]
			},

			"alphaCulling" => {
				vertexDefines: ["#define ALPHA_CULLING"],
				fragmentDefines: ["#define ALPHA_CULLING"],
				uniforms: [
					"alphaCullingValue" => { name: "u_alphaCullingValue", type: "float", shader: "f", slot: "0.0" }
				]
			},

			"normalMapping" => {
				vertexDefines: ["#define NORMAL_MAPPING"],
				fragmentDefines: ["#define NORMAL_MAPPING"],
				uniforms: [
					"normalMapTexture" => { name: "u_normalMapTexture", type: "texture", shader: "f" },
					"normalMapUvScaleOffset" => { name: "u_normalMapUvScaleOffset", type: "vec4", shader: "v", defaultValue: "[1.0, 1.0, 0.0, 0.0]" }
				]
			}
		];
	}

	public function addShaderConfigs(shaderConfigs:Map<String, ShaderInfo>) {
		for (shaderName in shaderConfigs.keys()) {
			var shaderInfo = shaderConfigs.get(shaderName);

			this._baseShaderConfigs.set(shaderName, shaderInfo);
		}
	}

	public function getShaderInfo(shaderName:String):ShaderInfo {
		var shaderConfig:ShaderInfo = null;
		if (this._shaderConfigs.exists(shaderName)) {
			shaderConfig = this._shaderConfigs.get(shaderName);

		} else {
			if (shaderName.indexOf(EXTENSION_SEPARATOR) == -1) {
				// Simple shader without extensions
				if (this._baseShaderConfigs.exists(shaderName)) {
					shaderConfig = ShaderUtils.cloneShaderInfo(this._baseShaderConfigs.get(shaderName));

					// Preprocess variables
					this.preprocessShaderConfig(shaderConfig);

					// Store configuration
					this._shaderConfigs.set(shaderName, shaderConfig);
				}

			} else {
				// Convert name into base and extensions
				var shaderComponents = shaderName.split(EXTENSION_SEPARATOR);
				if (shaderComponents.length > 0) {

					// Get base shader config
					var baseName = shaderComponents.shift();
					var baseShaderConfig = null;
					if (this._baseShaderConfigs.exists(baseName)) {
						baseShaderConfig = this._baseShaderConfigs.get(baseName);
					}

					// Verify and get all extensions
					var allExtensionsExist = true;
					var extensionsConfigs = new Array<ShaderExtensionInfo>();
					for (extensionName in shaderComponents) {
						if (!this._shaderExtensions.exists(extensionName)) {
							allExtensionsExist = false;
						}
					}


					// Continue to create full config if all ok
					if (baseShaderConfig != null && allExtensionsExist) {
						shaderConfig = ShaderUtils.cloneShaderInfo(baseShaderConfig);

						// Add extension configurations to base configuration
						for (extensionName in shaderComponents) {
							var extensionConfig = this._shaderExtensions.get(extensionName);
							ShaderUtils.extendShaderInfo(shaderConfig, extensionConfig, shaderName, extensionName);
						}

						// Preprocess variables
						this.preprocessShaderConfig(shaderConfig);

						// Store new configuration
						this._shaderConfigs.set(shaderName, shaderConfig);
					}
				}
			}
		}

		return shaderConfig;
	}


	private function preprocessShaderConfig(shaderConfig:ShaderInfo):Void {
		if (shaderConfig.variables != null) {
			for (variable in shaderConfig.variables) {
				ShaderUtils.processVariableForShaderConfig(shaderConfig, variable);
			}
		}
	}

}